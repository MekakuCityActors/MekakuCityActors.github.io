{"meta":{"title":"MekakuCityActors's blog","subtitle":null,"description":null,"author":"MekakuCityActors","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2018-12-28T10:57:39.000Z","updated":"2018-12-28T10:57:39.928Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"search","date":"2018-12-28T10:57:24.000Z","updated":"2018-12-28T10:57:24.393Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"BZOJ1001","slug":"BZOJ1001","date":"2018-12-27T13:45:36.000Z","updated":"2018-12-31T13:57:50.574Z","comments":true,"path":"2018/12/27/BZOJ1001/","link":"","permalink":"http://yoursite.com/2018/12/27/BZOJ1001/","excerpt":"","text":"1001: [BeiJing2006]狼抓兔子 Time Limit: 15 Sec Memory Limit: 162 MB Description 现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的， 而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形： 左上角点为(1,1),右下角点为(N,M)(上图中N=4,M=5).有以下三种类型的道路 1:(x,y)&lt;==&gt;(x+1,y) 2:(x,y)&lt;==&gt;(x,y+1) 3:(x,y)&lt;==&gt;(x+1,y+1) 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. Input 第一行为N,M.表示网格的大小，N,M均小于等于1000. 接下来分三部分 第一部分共N行，每行M-1个数，表示横向道路的权值. 第二部分共N-1行，每行M个数，表示纵向道路的权值. 第三部分共N-1行，每行M-1个数，表示斜向道路的权值. 输入文件保证不超过10M Output 输出一个整数，表示参与伏击的狼的最小数量. Sample Input 3 4 5 6 4 4 3 1 7 5 3 5 6 7 8 8 7 6 5 5 5 5 6 6 6 Sample Output 14 题目大意：求网格图的最大流。 题解：最大流=最小割，而平面图的最小割可以把原图转化为对偶图，然后利用最短路解决。注意前提必须是平面图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/************************************************************** Problem: 1001 User: MekakuCityActors Language: C++ Result: Accepted Time:940 ms Memory:143480 kb****************************************************************/#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;bitset&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;struct edge&#123; int x; int y; int val; int nex;&#125;e[6000005];int cnt,head[6200005],dist[6200005],n,m;void adde(int X,int Y,int Z)&#123; e[cnt].x=X; e[cnt].y=Y; e[cnt].val=Z; e[cnt].nex=head[X]; head[X]=cnt++;&#125;struct pot&#123; int x; int val; bool operator&lt;(const struct pot &amp;aa)const&#123; return val&gt;aa.val; &#125;&#125;;void dij()&#123; memset(dist,0x3f3f3f3f,sizeof(dist)); dist[1]=0; priority_queue&lt;struct pot&gt;pq; struct pot p0; p0.x=1; p0.val=0; pq.push(p0); while(!pq.empty())&#123; struct pot b0=pq.top();pq.pop(); if(b0.x==2*(n-1)*(m-1)+2)break; if(dist[b0.x]&lt;b0.val)continue; for(int i=head[b0.x];i!=-1;i=e[i].nex)&#123; int v=e[i].y; if(dist[v]&gt;dist[b0.x]+e[i].val)&#123; dist[v]=dist[b0.x]+e[i].val; struct pot c0; c0.x=v; c0.val=dist[v]; pq.push(c0); &#125; &#125; &#125;&#125;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); cin&gt;&gt;n&gt;&gt;m; memset(head,-1,sizeof(head)); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m-1;j++)&#123; int a; scanf(\"%d\",&amp;a); int x=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2; if(i==0)x=2*(n-1)*(m-1)+2; int y=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2-2*m+3; if(i==n-1)y=1; adde(x,y,a); adde(y,x,a); &#125; &#125; for(int i=1;i&lt;=n-1;i++)&#123; for(int j=0;j&lt;m;j++)&#123; int a; scanf(\"%d\",&amp;a); int x=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2; if(j==m-1)x=2*(n-1)*(m-1)+2; int y=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2-1; if(j==0)y=1; adde(x,y,a); adde(y,x,a); &#125; &#125; for(int i=1;i&lt;=n-1;i++)&#123; for(int j=0;j&lt;m-1;j++)&#123; int a; scanf(\"%d\",&amp;a); int x=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2; int y=x+1; adde(x,y,a); adde(y,x,a); &#125; &#125; if(n==1&amp;&amp;m==1)&#123; printf(\"0\\n\"); &#125; else&#123; dij(); printf(\"%d\\n\",dist[2*(n-1)*(m-1)+2]); &#125; return 0;&#125;","categories":[],"tags":[]}]}