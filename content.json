{"meta":{"title":"MekakuCityActors's blog","subtitle":null,"description":null,"author":"MekakuCityActors","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2018-12-28T10:57:39.000Z","updated":"2018-12-28T10:57:39.928Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"search","date":"2018-12-28T10:57:24.000Z","updated":"2018-12-28T10:57:24.393Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"点分治","slug":"点分治","date":"2019-02-22T03:02:29.138Z","updated":"2019-02-22T03:27:19.178Z","comments":true,"path":"2019/02/22/点分治/","link":"","permalink":"http://yoursite.com/2019/02/22/点分治/","excerpt":"","text":"两道点分治的板子题 P3806 【模板】点分治1 题目描述 给定一棵有n个点的树 询问树上距离为k的点对是否存在。 输入输出格式 输入格式：n,m 接下来n-1条边a,b,c描述a到b有一条长度为c的路径 接下来m行每行询问一个K 输出格式：对于每个K每行输出一个答案，存在输出“AYE”,否则输出”NAY”(不包含引号) 输入输出样例 输入样例#1： 2 1 1 2 2 2 输出样例#1： AYE 说明 对于30%的数据n&lt;=100 对于60%的数据n&lt;=1000,m&lt;=50 对于100%的数据n&lt;=10000,m&lt;=100,c&lt;=1000,K&lt;=10000000 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;using namespace std;typedef struct edge&#123; int next,to,w;&#125;edge;const int INF=1000000000;edge e[20010];int n,m,et,head[10010],siz[10010],vis[10010],maxs[10010],ans[110],q[110],w[10000010],root;stack&lt;int&gt; s,cur;inline int read()&#123; int num=0,k=1; char c=getchar(); while(c&gt;'9' || c&lt;'0') k=(c=='-')?0:k,c=getchar(); while(c&gt;='0' &amp;&amp; c&lt;='9') num=num*10+c-'0',c=getchar(); return k?num:-num;&#125;void addedge(int u,int v,int w)&#123; e[++et].to=v; e[et].next=head[u]; e[et].w=w; head[u]=et; e[++et].to=u; e[et].next=head[v]; e[et].w=w; head[v]=et;&#125;void getroot(int x,int fa,int sum)&#123; siz[x]=1; maxs[x]=0; for(int i=head[x],to;i;i=e[i].next)&#123; to=e[i].to; if(to==fa || vis[to]) continue; getroot(to,x,sum); siz[x]+=siz[to]; maxs[x]=max(maxs[x],siz[to]); &#125; maxs[x]=max(maxs[x],sum-siz[x]); if(maxs[root]&gt;maxs[x]) root=x;&#125;void cal(int x,int fa,int l)&#123; cur.push(l); for(int i=1;i&lt;=m;i++) if(l&lt;=q[i] &amp;&amp; w[q[i]-l]) ans[i]=1; siz[x]=1; for(int i=head[x],to;i;i=e[i].next)&#123; to=e[i].to; if(to==fa || vis[to]) continue; cal(to,x,l+e[i].w); siz[x]+=siz[to]; &#125;&#125;void solve(int x)&#123; vis[x]=1; while(!s.empty()) &#123;w[s.top()]=0; s.pop();&#125; w[0]=1; for(int i=head[x],to;i;i=e[i].next)&#123; to=e[i].to; if(vis[to]) continue; cal(to,x,e[i].w); while(!cur.empty()) &#123;w[cur.top()]=1; s.push(cur.top()); cur.pop();&#125; &#125; for(int i=head[x],to;i;i=e[i].next)&#123; to=e[i].to; if(vis[to]) continue; root=0; getroot(to,x,siz[to]); solve(root); &#125;&#125;int main()&#123; n=read(); m=read(); maxs[0]=INF; for(int i=1;i&lt;n;i++)&#123; int u=read(),v=read(),w=read(); addedge(u,v,w); &#125; for(int i=1;i&lt;=m;i++) q[i]=read(); root=0; getroot(1,0,n); solve(root); for(int i=1;i&lt;=m;i++) printf(\"%s\\n\",ans[i]?\"AYE\":\"NAY\");&#125; P2634 [国家集训队]聪聪可可 题目描述 聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。 他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画n个“点”，并用n-1条“边”把这n个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是3的倍数，则判聪聪赢，否则可可赢。 聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 输入输出格式 输入格式： 输入的第1行包含1个正整数n。后面n-1行，每行3个整数x、y、w，表示x号点和y号点之间有一条边，上面的数是w。 输出格式： 以即约分数形式输出这个概率（即“a/b”的形式，其中a和b必须互质。如果概率为1，输出“1/1”）。 输入输出样例 输入样例#1： 5 1 2 1 1 3 2 1 4 1 2 5 3 输出样例#1： 13/25 说明 【样例说明】 13组点对分别是(1,1) (2,2) (2,3) (2,5) (3,2) (3,3) (3,4) (3,5) (4,3) (4,4) (5,2) (5,3) (5,5)。 【数据规模】 对于100%的数据，n&lt;=20000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;struct edge&#123; int x; int y; int z; int nex;&#125;e[40005];stack&lt;int&gt;s,cur;int head[20005],ans,rt,cnt,cnt2[3],siz[20005],maxnv[20005],sum;bool vis[20005];int gcd(int a,int b)&#123; if(b==0)return a; return gcd(b,a%b);&#125;void adde(int a,int b,int c)&#123; e[cnt].x=a; e[cnt].y=b; e[cnt].z=c; e[cnt].nex=head[a]; head[a]=cnt++;&#125;void getrt(int u,int fa)&#123; siz[u]=1;maxnv[u]=0; for(int i=head[u];i!=-1;i=e[i].nex)&#123; int v=e[i].y; if(vis[v]||v==fa)continue; getrt(v,u); siz[u]+=siz[v]; maxnv[u]=max(maxnv[u],siz[v]); &#125; maxnv[u]=max(maxnv[u],sum-siz[u]); if(maxnv[u]&lt;maxnv[rt])rt=u;&#125;void cal(int u,int val,int fa)&#123; cur.push(val%3);ans+=cnt2[(3-(val%3))%3];//cout&lt;&lt;(3-(val%3))%3&lt;&lt;endl; for(int i=head[u];i!=-1;i=e[i].nex)&#123; int v=e[i].y; if(vis[v]||v==fa)continue; cal(v,e[i].z+val,u); &#125;&#125;void solve(int u)&#123; vis[u]=1; while(!s.empty())&#123;cnt2[s.top()]=0;s.pop();&#125;cnt2[0]=1; for(int i=head[u];i!=-1;i=e[i].nex)&#123; int v=e[i].y; if(vis[v])continue; cal(v,e[i].z,u); while(!cur.empty())&#123;cnt2[cur.top()]++;s.push(cur.top());cur.pop();&#125; &#125; for(int i=head[u];i!=-1;i=e[i].nex)&#123; int v=e[i].y; if(vis[v])continue; sum=siz[v]; rt=0; getrt(v,u); solve(rt); &#125;&#125;int main()&#123; int n; memset(head,-1,sizeof(head)); cin&gt;&gt;n; for(int i=1;i&lt;n;i++)&#123;int a,b,c;scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c);adde(a,b,c);adde(b,a,c);&#125; sum=n; rt=0; maxnv[0]=0x3f3f3f3f; getrt(1,0); solve(rt); int x=gcd(ans*2+n,(n*(n))); printf(\"%d/%d\\n\",(ans*2+n)/x,(n*(n))/x); return 0;&#125;","categories":[],"tags":[]},{"title":"BZOJ1001","slug":"BZOJ1001","date":"2018-12-27T13:45:36.000Z","updated":"2019-02-03T02:31:39.136Z","comments":true,"path":"2018/12/27/BZOJ1001/","link":"","permalink":"http://yoursite.com/2018/12/27/BZOJ1001/","excerpt":"","text":"1001: [BeiJing2006]狼抓兔子 Time Limit: 15 Sec Memory Limit: 162 MB Description 现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的， 而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形： 左上角点为(1,1),右下角点为(N,M)(上图中N=4,M=5).有以下三种类型的道路 1:(x,y)&lt;==&gt;(x+1,y) 2:(x,y)&lt;==&gt;(x,y+1) 3:(x,y)&lt;==&gt;(x+1,y+1) 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角(1,1)的窝里，现在它们要跑到右下解(N,M)的窝中去，狼王开始伏击这些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为K，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. Input 第一行为N,M.表示网格的大小，N,M均小于等于1000. 接下来分三部分 第一部分共N行，每行M-1个数，表示横向道路的权值. 第二部分共N-1行，每行M个数，表示纵向道路的权值. 第三部分共N-1行，每行M-1个数，表示斜向道路的权值. 输入文件保证不超过10M Output 输出一个整数，表示参与伏击的狼的最小数量. Sample Input 3 4 5 6 4 4 3 1 7 5 3 5 6 7 8 8 7 6 5 5 5 5 6 6 6 Sample Output 14 题目大意：求网格图的最大流。 题解：最大流=最小割，而平面图的最小割可以把原图转化为对偶图，然后利用最短路解决。注意前提必须是平面图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/************************************************************** Problem: 1001 User: MekakuCityActors Language: C++ Result: Accepted Time:940 ms Memory:143480 kb****************************************************************/#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;bitset&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;struct edge&#123; int x; int y; int val; int nex;&#125;e[6000005];int cnt,head[6200005],dist[6200005],n,m;void adde(int X,int Y,int Z)&#123; e[cnt].x=X; e[cnt].y=Y; e[cnt].val=Z; e[cnt].nex=head[X]; head[X]=cnt++;&#125;struct pot&#123; int x; int val; bool operator&lt;(const struct pot &amp;aa)const&#123; return val&gt;aa.val; &#125;&#125;;void dij()&#123; memset(dist,0x3f3f3f3f,sizeof(dist)); dist[1]=0; priority_queue&lt;struct pot&gt;pq; struct pot p0; p0.x=1; p0.val=0; pq.push(p0); while(!pq.empty())&#123; struct pot b0=pq.top();pq.pop(); if(b0.x==2*(n-1)*(m-1)+2)break; if(dist[b0.x]&lt;b0.val)continue; for(int i=head[b0.x];i!=-1;i=e[i].nex)&#123; int v=e[i].y; if(dist[v]&gt;dist[b0.x]+e[i].val)&#123; dist[v]=dist[b0.x]+e[i].val; struct pot c0; c0.x=v; c0.val=dist[v]; pq.push(c0); &#125; &#125; &#125;&#125;int main()&#123; //freopen(\"in.txt\",\"r\",stdin); cin&gt;&gt;n&gt;&gt;m; memset(head,-1,sizeof(head)); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m-1;j++)&#123; int a; scanf(\"%d\",&amp;a); int x=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2; if(i==0)x=2*(n-1)*(m-1)+2; int y=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2-2*m+3; if(i==n-1)y=1; adde(x,y,a); adde(y,x,a); &#125; &#125; for(int i=1;i&lt;=n-1;i++)&#123; for(int j=0;j&lt;m;j++)&#123; int a; scanf(\"%d\",&amp;a); int x=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2; if(j==m-1)x=2*(n-1)*(m-1)+2; int y=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2-1; if(j==0)y=1; adde(x,y,a); adde(y,x,a); &#125; &#125; for(int i=1;i&lt;=n-1;i++)&#123; for(int j=0;j&lt;m-1;j++)&#123; int a; scanf(\"%d\",&amp;a); int x=2*(n-1)*(m-1)+2-2*(m-1)*i+j*2; int y=x+1; adde(x,y,a); adde(y,x,a); &#125; &#125; if(n==1&amp;&amp;m==1)&#123; printf(\"0\\n\"); &#125; else&#123; dij(); printf(\"%d\\n\",dist[2*(n-1)*(m-1)+2]); &#125; return 0;&#125;","categories":[],"tags":[]}]}